[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Zero 2 Programmer for Earth Scientists",
    "section": "",
    "text": "Computational Geosciences\nAs computing power advanced, the instructions understood by a computer could be expanded. In fact, it was no longer a waste of time and money to write computer programs in a human readable form and have the computer translate them to its own more basic instructions later. True programming begins in this way: creating a description of the operations that are going to be executed without having to know the underlying details of the machine that will be doing the computation.\nIt probably goes without saying that making that first abstract leap naturally leads to another and another. Programs become complex and it can be helpful to step up until we reach a level that does not deal with the details within a program but just treats it as a collection of operations that process information in a predictable manner. A library is a collection of operations that do a small number of jobs for several other programs to use but do little or nothing on their own.\nAdvancing computer power means that the computer does more of the work and allows a programmer to take a much higher-level view of the problem that needs to be solved. It also allows people to build and re-use very general libraries that have been thoroughly tested. It is usually not a problem that libraries do more than we need and this means that we don’t need to change any code in a library at the risk of breaking it.\nAt the very least, this means that, over time, we can expect software (programs) to grow more reliable and gain functionality as people fix and improve it because it is always being reused. The improvements in hardware are what make this possible.\nApple’s M1 chip has 16 billion transistors etched at a 5nm scale. It runs multiple different threads on the one chip and many of the subsystems that used to be on separate chips are integrated. It is not compatible with the previous generation of chips (it uses a different instruction set at the binary level) but it can emulate those chips when necessary and still has some speed advantage. This abundant power and storage means that you can concentrate on writing robust, flexible codes, not on puzzling over clever algorithms that are specially tuned for one particular architecture. Progress ! (Image copyright: Apple, 2020) ```\nIf the computer language that our software was written in is not the one we are using, no matter, we can simply write a translator of some kind and let the advancing hardware speeds and storage capacity make up for the extra cost. It is even possible to create software equivalents of the computer hardware (and the basic operating system) itself which makes it possible to create a computing “cloud” where the execution of your program may run anywhere or skip from machine to machine on demand including different hardware from where it started. This is another kind of re-use: making it possible to recreate or clone a running device at any time and receive identical results every single time.\n(section:acknowledgements)=",
    "crumbs": [
      "**Introduction**",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>About This Course</span>"
    ]
  },
  {
    "objectID": "index.html#computational-geosciences",
    "href": "index.html#computational-geosciences",
    "title": "Zero 2 Programmer for Earth Scientists",
    "section": "",
    "text": "```vsumzgbx Figures/UWtyping.gif\n\n\n\n\nwidth: 100%\n\n\nname: Someone knows python !\n\n\n\n\nLouis Moresi, Australian National University; Andrew Valentine, Durham University (formerly ANU); Navid Constantinou, Australian National University. Other authors have contributed material to this document (thank you !), see {ref}`section:acknowledgements` for a list.\n\nIn this course, we are first going to touch on some basic principles of programming, discuss what it even means to program a computer, and then move on to get a feel for what a program looks like using the `python` programming language for all of our examples. We are going to work mostly online using the `jupyter` literate computing interface to python as our electronic *lab notebook* and we are going to learn by example.\n\nWe are also trying to learn good programming habits - like writing a plan for our software before leaping in, using reliable version control (especially when working in teams), writing tests, adopting a helpful, clear programming style.\n\nThere is a [step-by-step guide](Notebooks/StepByStep/Introduction.md) to learning python programming and also a number of [deeper-dives](Notebooks/Themes/0-StartHere.md) into topics of relevance to Earth Science.\n\n## Introduction\n\nIn the history of computing, the concept of \"programming a computer\" has evolved rapidly in conjuction with a rapid expansion in processing power, storage and communication speed. It is helpful to look back and think about this progression as we think about the aspects of computer programming that persist through all of this change.\n\nWe take for granted the rapid improvements in computing technology that mean computing power doubles every year or two by almost every practical measure (This has become known as Moore's Law {cite}`moore_cramming_2006`). This fact, more than anything else, has dictated the path to more and more high-level thinking in how computer programs are created.\n\nEarly electronic computers were expensive and not especially powerful. They understood a rudimentary set of instructions and it was a very specialised job to write the instructions for any complex task that could solve some useful problem with the limited resources of such machines. Ingenuity was a key requirement for a programmer human effort in careful program design paid off in speedy, mistake-free computation.\n\n```{figure} https://csiropedia.csiro.au/wp-content/uploads/2015/01/6229923.jpg\n---\nwidth: 75mm\nname: csirac\n---\nCSIRAC was constructed by the Division of Radiophysics to the designs of Trevor Pearcey (pictured) and Maston Beard. This photo was taken on 5 November 1952. [Photo: CSIRO Archives]\n\n\n\n\n\n\n\n```vsumzgbx Figures/Apple_new-m1-chip_11102020.jpg\n\n\n\n\nwidth: 75mm\n\n\nname: M1",
    "crumbs": [
      "**Introduction**",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>About This Course</span>"
    ]
  },
  {
    "objectID": "index.html#acknowledgements",
    "href": "index.html#acknowledgements",
    "title": "Zero 2 Programmer for Earth Scientists",
    "section": "Acknowledgements",
    "text": "Acknowledgements\nThis text and the accompanying examples were written for teaching computer programming to students at the University of Melbourne and the Austalian National University. We include teaching material from Dan Sandiford and Ben Mather as well as examples taken from the gallery / cookbook pages of some of the packages we use. Where we know the source, we try to cite the source correctly but we are happy to be corrected where we have missed something. A good way to let us know is to raise an issue on the GitHub repository associated with this book which can be found here.",
    "crumbs": [
      "**Introduction**",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>About This Course</span>"
    ]
  },
  {
    "objectID": "WhatIsProgramming.html",
    "href": "WhatIsProgramming.html",
    "title": "Modern approaches to programming",
    "section": "",
    "text": "What is a computer ?\nModern programming has an organic, layered feel to it that may come as a surprise. In this course, we will learn how to read through the layers to understand how programs are built and how to build our own. Let us start with some very basic questions.\nA classical computer is an engine of some kind for processing pure information. Various components are needed to make this possible including some means of initialising and storing the information before and after it is processed, and a mechanism for processing information (including the case where the processing is dependent upon the information itself). Many different machines can meet these criteria but we usually add at least one more requirement: the computers that we are interested in are programmable in that they can be given different instructions that describe what processing will be done.\nThe original Analytical Engine designed by Babbage and Lovelace in the 1830s (see {cite}babbage_babbages_2010) fits these criteria and so do most modern digital computers. One of the pioneers of computing information theory, John von Neumann, describes the necessary requirements for a true computer and makes many very interesting comparisons between the digital computers of his time (the 1950s) and the human brain in his final book Computing and the Brain {cite}von_neumann_computer_2012.\nThere are many kinds of computers that we will not be discussing such as the embedded systems in controllers, engines, cars, aircraft and so on. Some of these might use recognisable programming but many are heavily focused on the job that they must do quickly, with low overhead and no danger of crashing as they process critical information in real time. These systems may well have more in common with early electronic computers because complexity can be the enemy of reliability or at least of demonstrating reliability in the face of every conceivable input.\nWe will also make an assumption that there is only one information processing engine that we are programming at any one time. Most computers are, in fact, multiple processing engines that work simultaneously either on different tasks that do not interact or on subsets of the information that are isolated from each other. Real parallel programming almost always requires us to understand and control how those data or task interdependencies work and that is an a subject in its own right.",
    "crumbs": [
      "**Introduction**",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Modern approaches to programming</span>"
    ]
  },
  {
    "objectID": "WhatIsProgramming.html#what-is-a-programming-language",
    "href": "WhatIsProgramming.html#what-is-a-programming-language",
    "title": "Modern approaches to programming",
    "section": "What is a programming language ?",
    "text": "What is a programming language ?\nBroadly speaking, a programming language is a way to tell a computer how to obtain and process information for us. There are two distinct paradigms in programming that approach problems in quite different ways.\nThe first of these is the declarative approach which states what needs to be done and does not say very much about how it needs to be done. Some examples of this are “Hey Siri …” or “Hey Google …” followed by some question such as “will it be hot today ?” and we expect some sort of reasonable response to that without further explanation. Another example is a spreadsheet where calculations mostly just happen without having to explain in detail how to sum a column or multiply two columns. This is also the way we usually interact with human experts !\nThe second paradigm is usually less familiar in our everyday experience. Imperative programming is what happens when you lay out every step in detail for the computer to follow and these steps will be followed to the letter no matter what mistakes you make in giving the instructions. We don’t give instructions to people at this level unless they have no experience whatsoever in some topic. “Would you make me a cup of tea, please ?” becomes “Walk from your current position to the kitchen and identify the kettle, turn the on/off switch to the on position …” and so on. Any of these steps is open to misinterpretation and misunderstanding so how do you know when to stop adding more details ?\nImperative programming is the way we will approach most science problems but we will also be making use of many libraries and modules that have already encoded the basic instructions for the kinds of tasks we want to do. Our job is often just trying our best to find these libraries, test them and work out all the things they can do. The many layers of abstraction are a way to know the appropriate level of detail in describing a task.\nA programming language is just a way to make the writing and executing of these instructions as simple and re-usable as makes sense for the task in hand. Some are very low level for programming individual chips, and some are very high level if, for example, we want to build an interactive website quickly and mostly according to a pre-existing recipe. Some programming languages trade ease of use for speed (languagues like C and Fortran are like this) and some are very flexible but have to do a lot of checks when they run to make sure all the ideas fit together consistently (Python is like that, and so is Perl). Some programming languages are just arrangements of logical blocks where we specify the operations and their interactions but not in text form (e.g. scratch) but they are still, at some level, explaining what to do, in what order, to which pieces of data.\nWe are going to concentrate on Python which is a flexible language that is widely used by the scientific community. I has a few things in common with English, actually, in that it is very good at absorbing concepts from other languages, and there are always many different ways to say something. Python makes it possible to create levels of abstraction that hide unimportant details but those details are not particularly well hidden and it is always possible to dig down and find out more.",
    "crumbs": [
      "**Introduction**",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Modern approaches to programming</span>"
    ]
  },
  {
    "objectID": "WhatIsProgramming.html#what-does-a-well-written-program-or-library-look-like",
    "href": "WhatIsProgramming.html#what-does-a-well-written-program-or-library-look-like",
    "title": "Modern approaches to programming",
    "section": "What does a well-written program or library look like ?",
    "text": "What does a well-written program or library look like ?\nOne of the first questions to ask before starting to write some code is “did somebody already write this ?” and, if the answer is yes, can you quickly work out which of these options is best: - Use the existing program or library - Modify the existing program or library - Start again\nIf you do decide to use somebody else’s code, you will need to understand how it works and check that it really does work as advertised. If you need to modify the code, you should consider whether you are going to contribute those improvements back to the author or the community.\nGoing through this process for somebody else’s code is also a very good idea before you write your own code because, honestly, it helps you to be as critical of your own work as you would be of others. Here is a checklist that feels a lot more intimidating if you imagine scrutinising your own programs, not somebody else’s:\n\nCan I find the source code ?\nIs the source code clear, readable with comments ?\nIs there a suite of tests with good coverage of the code ?\nAre the benchmarks or verifications of inputs v. outputs ?\nIs there clear documentation for a typical user or a typical developer?\nIs it clear how bug-fixes and improvements will be accepted ?\nIs the code up-to-date with the latest operating systems ?\n\nThe discussion so far gets us to the point where we know how to describe what we want from a piece of software even if we don’t know how to build it ourselves (another layer of abstraction, by the way) ! You are going to be encouraged to approach any task from this high level view. We will always start with the question - has somebody done this already ?",
    "crumbs": [
      "**Introduction**",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Modern approaches to programming</span>"
    ]
  },
  {
    "objectID": "WhatIsProgramming.html#how-do-we-take-advantage-of-re-usable-computing",
    "href": "WhatIsProgramming.html#how-do-we-take-advantage-of-re-usable-computing",
    "title": "Modern approaches to programming",
    "section": "How do we take advantage of re-usable computing ?",
    "text": "How do we take advantage of re-usable computing ?\nOur goal is to learn not just how to program a computer but how to write software that works and with all the tests to prove that it works; software that other people will find helpful and that they will be encouraged to use. That is to say, software that is “well-written” by the criteria we just discussed.\nWe will touch upon literate programming which is a way to interweave rich documentation (with full text, equations, images etc) into code so that it is automatically well explained and properly documented and also to ensure that the documentation and the code do not drift apart when changes are made.\nWe will discuss the benefits of making codes open-source and hosting them on a public repository so that they are easily discoverable. We will discuss version control and testing and the benefits of merging those two things into one process so that you can be sure each change you make to the code does not introduce errors in other parts of the code.",
    "crumbs": [
      "**Introduction**",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Modern approaches to programming</span>"
    ]
  },
  {
    "objectID": "WhatIsProgramming.html#what-is-the-role-of-a-human-programmer-in-a-world-of-ai",
    "href": "WhatIsProgramming.html#what-is-the-role-of-a-human-programmer-in-a-world-of-ai",
    "title": "Modern approaches to programming",
    "section": "What is the role of a human programmer in a world of AI ?",
    "text": "What is the role of a human programmer in a world of AI ?\nWhy don’t we start by asking the AI ?\n\n\n\n\n\n\nThe Evolving Role of Human Programmers in an AI-Assisted World\n\n\n\n\n\nAs AI code generation capabilities advance, the human programmer’s role will shift rather than disappear:\n\nStrategic Direction & Problem Definition\n\nDefining what needs to be built and why\nTranslating business needs into technical requirements\nSetting architectural vision and system design principles\nMaking critical decisions about tradeoffs (performance, scalability, cost)\n\n\n\nAI Collaboration & Oversight\n\nPrompting AI effectively to generate useful code\nReviewing, validating, and improving AI-generated solutions\nEnsuring AI output meets business requirements and constraints\nHandling edge cases and complex scenarios AI struggles with\n\n\n\nDomain Expertise & Context\n\nProviding specialized industry/business knowledge\nUnderstanding organizational context and constraints\nEmbedding ethical considerations and company values\nEnsuring compliance with regulations and standards\n\n\n\nSystem Integration & Complexity Management\n\nDesigning how components interact in complex systems\nManaging dependencies and technical debt\nEnsuring performance, security, and reliability\nSolving novel problems AI hasn’t encountered\n\n\n\nInnovation & Creativity\n\nExploring new approaches and technologies\nCreating solutions for previously unsolved problems\nDeveloping new frameworks and paradigms\nPushing the boundaries of what’s technically possible\n\nThe programmer becomes less of a code producer and more of a technical director, leveraging AI as a powerful tool while maintaining responsibility for the overall quality, appropriateness, and effectiveness of technical solutions.",
    "crumbs": [
      "**Introduction**",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Modern approaches to programming</span>"
    ]
  },
  {
    "objectID": "WhatIsProgramming.html#strategic-direction-problem-definition",
    "href": "WhatIsProgramming.html#strategic-direction-problem-definition",
    "title": "Modern approaches to programming",
    "section": "Strategic Direction & Problem Definition",
    "text": "Strategic Direction & Problem Definition\n\nDefining what needs to be built and why\nTranslating business needs into technical requirements\nSetting architectural vision and system design principles\nMaking critical decisions about tradeoffs (performance, scalability, cost)",
    "crumbs": [
      "**Introduction**",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Modern approaches to programming</span>"
    ]
  },
  {
    "objectID": "WhatIsProgramming.html#ai-collaboration-oversight",
    "href": "WhatIsProgramming.html#ai-collaboration-oversight",
    "title": "Modern approaches to programming",
    "section": "AI Collaboration & Oversight",
    "text": "AI Collaboration & Oversight\n\nPrompting AI effectively to generate useful code\nReviewing, validating, and improving AI-generated solutions\nEnsuring AI output meets business requirements and constraints\nHandling edge cases and complex scenarios AI struggles with",
    "crumbs": [
      "**Introduction**",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Modern approaches to programming</span>"
    ]
  },
  {
    "objectID": "WhatIsProgramming.html#domain-expertise-context",
    "href": "WhatIsProgramming.html#domain-expertise-context",
    "title": "Modern approaches to programming",
    "section": "Domain Expertise & Context",
    "text": "Domain Expertise & Context\n\nProviding specialized industry/business knowledge\nUnderstanding organizational context and constraints\nEmbedding ethical considerations and company values\nEnsuring compliance with regulations and standards",
    "crumbs": [
      "**Introduction**",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Modern approaches to programming</span>"
    ]
  },
  {
    "objectID": "WhatIsProgramming.html#system-integration-complexity-management",
    "href": "WhatIsProgramming.html#system-integration-complexity-management",
    "title": "Modern approaches to programming",
    "section": "System Integration & Complexity Management",
    "text": "System Integration & Complexity Management\n\nDesigning how components interact in complex systems\nManaging dependencies and technical debt\nEnsuring performance, security, and reliability\nSolving novel problems AI hasn’t encountered",
    "crumbs": [
      "**Introduction**",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Modern approaches to programming</span>"
    ]
  },
  {
    "objectID": "WhatIsProgramming.html#innovation-creativity",
    "href": "WhatIsProgramming.html#innovation-creativity",
    "title": "Modern approaches to programming",
    "section": "Innovation & Creativity",
    "text": "Innovation & Creativity\n\nExploring new approaches and technologies\nCreating solutions for previously unsolved problems\nDeveloping new frameworks and paradigms\nPushing the boundaries of what’s technically possible\n\nThe programmer becomes less of a code producer and more of a technical director, leveraging AI as a powerful tool while maintaining responsibility for the overall quality, appropriateness, and effectiveness of technical solutions.",
    "crumbs": [
      "**Introduction**",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Modern approaches to programming</span>"
    ]
  },
  {
    "objectID": "Intro2PythonLanguage.html",
    "href": "Intro2PythonLanguage.html",
    "title": "What kind of Language is Python ?",
    "section": "",
    "text": "What kind of Language is Python ?\nThere are some things worth knowing about the python language before diving in. Perhaps the most important thing to be aware of is that python is an interpreted language rather than a compiled language so there is no translation to fast, machine-executable, binary code. This firmly places efficient coding ahead of fast execution and says a great deal about the philosophy of python as a language: applicable to a very broad class of problems, easy to read and high-level so that it is straightforward to re-use and build upon existing software.\nPython is supposed to be easy to use: it does not require you to specify (“declare”) the type of your variables or data before using them and it is happy to convert automatically from one type to another when it makes sense to do so. For example, a floating point 1.0 and an integer 1 are mostly interchangeable in python as they are in everyday life. When you have finished using a variable, there is no need to explicitly delete it though you can if you wish. Python is generally very permissive: there are usually many different ways to write something in python and the one that is easiest to follow is usually the best option to choose.\nPython has extensive exception handling which simply means that errors can be handled by the running program not always resulting in a crash that is deal with by the operating system. In general, it is a good idea to write code that understands what might go wrong and provides an elegant landing if something does. Exceptions also lead to a try it and see approach to programming. It can be easier to write code to catch an error than to try to write code that accounts for every situation without fail (at some point it will fail anyway !).\nPython is also an object oriented language and it is impossible to read python without understanding how it describes its objects and then refers to them. The principle of object-oriented languages is to encapsulate data and operations on that data into “objects” that can be passed around as a single entity and which you then can use without having to know all the internal structure of the object. This is a key part of our earlier discussion about the importance of being able to create abstractions in programming. In object-oriented languages, we typically describe a class of objects that have certain properties (data, operations, structure) without necessarily knowing the details of how those objects are implemented. We can be handed classes and told how to use them, copy them, extend them and so on without having to pull them apart first.\nPython is based around libraries in the form of modules that we import when we need to use them. There are very many modules in the standard python library for doing nearly everything from the operating-system level (make a directory, open a file) to high-level access to internet resources, string manipulations, regular expression parsing, mathematical functions … [links would be helpful]. Once a module is imported, the functions and classes that it defines become available to the program and to make life simpler, the names of all those functions and classes are prefaced by the module name when they are used. That means math.sin is not confused with religion.sin which might take a bit more typing for a programmer but does improve readability and makes life much, much easier for anyone developing a library.\nIf you write some useful code, it is common to bundle it into the form of a module and then to distribute it by uploading a package to a standard location. These packages are then distributed to users via a package manager which is smart enough to make sure that you are installing a version that works on your machine and (more complicated) is consistent with all the other packages you have installed.\nThe two main package managers for python are pip and conda. pip is a little bit more simple and really just worries about installing python packages and their python dependencies. pip is usually used in conjunction with other package managers to handle other dependencies that are distributed as binary libraries (things not derived from python - for example visualisation packages, compilers, language parsers, numerical libraries written in fortran). conda is a great deal more ambitious than pip- it manages entire environments that also include non-python libraries that packages might need. conda is more powerful than pip and tries to replace many other package managers that exist in the non-python world. If you do opt for conda, you really should go the whole nine-yards and try to use it to manage everything. conda creates virtual environments which allow you to have multiple set-ups on a single machine - handy if you have packages that need different versions of python or which have incompatible dependencies. conda is very handy for cloud computing because it a simple text file is (usually) enough to specify how to set up a cloud machine to run the environment you need.",
    "crumbs": [
      "**Introduction**",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>What kind of Language is Python ?</span>"
    ]
  },
  {
    "objectID": "Intro2PythonLanguage.html#background-reading",
    "href": "Intro2PythonLanguage.html#background-reading",
    "title": "What kind of Language is Python ?",
    "section": "Background reading",
    "text": "Background reading\nThe definitive reference point for python is www.python.org. It might be helpful to browse various articles on wikipedia first, though, starting with the page about the Python language",
    "crumbs": [
      "**Introduction**",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>What kind of Language is Python ?</span>"
    ]
  },
  {
    "objectID": "TLDR.html",
    "href": "TLDR.html",
    "title": "TLDR - Python Phrase Book",
    "section": "",
    "text": "Obligatory Hello world program\nThe first thing we should do is become familiar with the shape and feel of python code because we can’t really discuss the features of python without a few examples. So here is a little phrase book …\nThere is no set up needed to run this simple example because the print command is built into python. It is actually implemented as a function that displays its argument to the screen, so now you know what python functions look like ! You can also see how to write a comment.\nHere are a couple of other ways to do the same thing\nWe can assign the message to a variable and print that directly. The print function does not need to be told that hello_world_string is a string (and the fact that the name has the word string in it is neither here nor there). Variable names are allowed to have underscore characters in them, letters and numbers (other than the first character, that can’t be a number). underscores at the beginning of a variable are conventionally “hidden” which actually just means they are a bit harder to find in an interactive environment.",
    "crumbs": [
      "**Introduction**",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>TLDR - Python Phrase Book</span>"
    ]
  },
  {
    "objectID": "TLDR.html#obligatory-hello-world-program",
    "href": "TLDR.html#obligatory-hello-world-program",
    "title": "TLDR - Python Phrase Book",
    "section": "",
    "text": "&gt;&gt;&gt;\nHello World\n\n\n\n\n\n\n\n\n&gt;&gt;&gt;\nHello World\n-- Hello World --\n\n\n\n\n\n\n\nPython objects and methods are everywhere!\n\n\n\nIn fact, the string is a python object that understands that it may need to be printed and will respond appropriately to the print function’s call. The format function is also part of the repertoire of the string object and we will see this object.function way of accessing the “methods” of an object very, very often.",
    "crumbs": [
      "**Introduction**",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>TLDR - Python Phrase Book</span>"
    ]
  },
  {
    "objectID": "TLDR.html#indentation-and-block-structure",
    "href": "TLDR.html#indentation-and-block-structure",
    "title": "TLDR - Python Phrase Book",
    "section": "Indentation and block structure",
    "text": "Indentation and block structure\npython uses indentation to define code blocks and will complain when the indentation is broken. This is important for defining functions, conditional statements, loops and so on:\n\nLoops and if statements\n\n\n\n\n\n\nThis has the layout of a typical python code - the blocks that make up a loop or the branches of conditions are defined by the indentation. Easy if the code is short, much harder to follow if you cram too much into a block.",
    "crumbs": [
      "**Introduction**",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>TLDR - Python Phrase Book</span>"
    ]
  },
  {
    "objectID": "TLDR.html#functions",
    "href": "TLDR.html#functions",
    "title": "TLDR - Python Phrase Book",
    "section": "Functions",
    "text": "Functions\n\n\n\n\n\n\n&gt;&gt;&gt;\n1\nHello world\n\nHelp on function my_first_function in module __main__:\n\nmy_first_function(argument1, argument2)\n    This is the \"help\" for a function a.k.a. docstring. This particular function returns\n    its first argument\n\n\n\n\n\n\n&gt;&gt;&gt;\n(1, 2)\n('Hello world', 0)\nHelp on function my_second_function in module __main__:\n\nmy_second_function(argument1, argument2)\n    Function returns both arguments\n\n1\n2\nFunctions can return many arguments and they come back as a tuple. It is straightforward to unpack the values that are returned (the last example above).\n\n\n\n\n\n\nInterpreters vs Compilers\n\n\n\nSince python is an interpreted language, you must define functions before they are encountered in the code. That inverts the way many people write their code with the subroutines defined after the logic of the code is laid out. Instead, python uses modules to organise collections of code that are defined outside the main flow of the code.",
    "crumbs": [
      "**Introduction**",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>TLDR - Python Phrase Book</span>"
    ]
  },
  {
    "objectID": "TLDR.html#modules",
    "href": "TLDR.html#modules",
    "title": "TLDR - Python Phrase Book",
    "section": "Modules",
    "text": "Modules\nThe power of python is probably in the way it encourages sharing and builds a community of users. Before we can do much with python, we generally need to import the modules with the extra functionality we need. The print function is unusual in not needing to be imported, nearly everything else we want to do needs an import first\nFor example, the standard python library comes with modules for basic file system operations, string manipulation, mathematical functions, spawning processes … and so on. The full list is in the python documentation. These capabilities are provided (if you have downloaded python, you have these modules) but are not automatically activated.\nHere are a couple of examples:\nimport math\n\nprint(math.sin(math.pi/2))\nprint(math.cos(math.pi/2))\n&gt;&gt;&gt;\n1.0\n6.123233995736766e-17\nSee how the module.function works. Sometimes, you just want to import a few bits and pieces and you can save some typing by importing those functions at the base level - they can then be used without referencing the module name (if the names do not clash, of course, and provided you remember to import everything you need !)\n\nfrom math import sin, pi\n\nprint(sin(pi/2))\nprint(cos(pi/2))\n&gt;&gt;&gt;\n1.0\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\n&lt;ipython-input-7-2b3c4d0b7471&gt; in &lt;module&gt;\n      4\n      5 #\n----&gt; 6 print(cos(pi/2))\n\nNameError: name 'cos' is not defined\nYou can change the names when you import to avoid clashes. Here is an example using cmath which is the complex math library complementary to the standard (real numbers) math library.\nfrom math import sin, pi\nfrom cmath import sin as csin\n\nprint(sin(pi/2))\nprint(csin(pi/2))\n&gt;&gt;&gt;\n1.0\n(1+0j)\nIf it makes sense to you, import modules under a different name too\nimport math as real_math\nimport cmath as complex_math\n\nprint(real_math.sin(real_math.pi))",
    "crumbs": [
      "**Introduction**",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>TLDR - Python Phrase Book</span>"
    ]
  },
  {
    "objectID": "TLDR.html#parlez-vous-python-beszélsz-pythonban",
    "href": "TLDR.html#parlez-vous-python-beszélsz-pythonban",
    "title": "TLDR - Python Phrase Book",
    "section": "Parlez-vous Python / Beszélsz pythonban ?",
    "text": "Parlez-vous Python / Beszélsz pythonban ?\nNot yet !\nBut now you should have some sense of what a python code looks like and why it will break if you type the wrong number of spaces and how dots are used to denote a hierarchy. Next we can take a look at the different types of data in python and then go on to explore how data and functions are bundled together in python objects. All the while, it is fine to dip in to the step-by-step examples.\nBut it would be useful for us to be able to try out examples and for that, we will want to use live documents and, later, jupyter notebooks.\n\n\n\n\n\n\nCoding scratch space",
    "crumbs": [
      "**Introduction**",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>TLDR - Python Phrase Book</span>"
    ]
  },
  {
    "objectID": "Basics/Ex1-IntroWebPython.html",
    "href": "Basics/Ex1-IntroWebPython.html",
    "title": "Python on the web",
    "section": "",
    "text": "Comments\nThere are many different ways to run python code. For the simplest tasks, a web browser is all you need to edit and run simple tasks. In this introductory session, we will use a python interpreter embedded in each web page to learn the basic language itself.\nYou will find examples of python code such as this one which contains some Python code which you can copy but which you can’t run and you can’t edit. Note that the code is highlighted (coloured) by meaning.\nWe use these blocks to give you examples and fragments of code that you can use later. Other code blocks have a run button and they can usually be edited (and, don’t worry, they can be reset if you make a mistake). We use these live code blocks for you to try things out. Give it a go (you can’t break anything).\nGenerally, we’ll use the live code blocks as part of an exercise for you to try something specific. The exercise blocks look like this:\nWe’ve already seen a couple of examples of Python code. Now let’s try making something from scratch. One thing we can do is simply use Python like a calculator!\nIn the examples above, you may have noticed the line\nwhich doesn’t look as though it ought to be valid Python code. This is a ‘comment’ line: the computer ignores the # and anything following it on the same line. Comments should be used to document information that helps people to understand how the code works internally. This may seem like a waste of time - but you (or your colleagues) will be grateful in two years’ time when you find you need to change something! The comment character can also be useful for ‘switching off’ lines of code without deleting them. For example, look at this piece of code:\nThe first three lines of comments provide information recording some of the assumptions the programmer made when writing this function (don’t worry if it doesn’t make sense yet!). The fourth comment line is a piece of code that has been ‘commented out’: we don’t want to routinely print the file header, but it is useful to be able to reinstate this easily in case we encounter problems and need to check what the function has read.\nIn fact, ‘commenting out’ code is so common that most editors provide a straightforward way to do it. If you select a block of code and press Ctrl+/ (or on a Mac, ⌘+/), the selected lines will all be changed to begin with # comment characters. Pressing Ctrl+/ again will restore the original version. Smart editors know how to do this for many different languages.",
    "crumbs": [
      "**Basic Language Skills**",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Python on the web</span>"
    ]
  },
  {
    "objectID": "Basics/Ex1-IntroWebPython.html#exercises-with-solutions",
    "href": "Basics/Ex1-IntroWebPython.html#exercises-with-solutions",
    "title": "Python on the web",
    "section": "Exercises with Solutions",
    "text": "Exercises with Solutions\nIn some cases, you can check your answers by running the code and comparing the output to the expected result. Here is a simple example in which you are asked to write some code to print the mean of the integers from 1 to 99.\n\n\n\n\n\n\nExercise 3 - Checking your answers\n\n\n\n\n\nComplete the code below and ensure that the last line is the result of the computation\n\n\n\n\n\n\n\n\n\n\n\n\n\nHint\n\n\n\n\n\n\ntotal = 0\nfor i in n:\n    total += i\n\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\ntotal = 0\nfor i in n:\n    total += i\nmean = total/len(n)\nmean\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCoding scratch space",
    "crumbs": [
      "**Basic Language Skills**",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Python on the web</span>"
    ]
  },
  {
    "objectID": "Basics/Ex2-Variables.html",
    "href": "Basics/Ex2-Variables.html",
    "title": "Variables",
    "section": "",
    "text": "Using variables\nWe saw in the last exercise that Python can do simple calculations, such as\nOn its own, this isn’t terribly useful. However, we can store the results of calculations, by ‘assigning’ them to a ‘variable’. To do this, we just need to type\nWe can use any name we want, provided it:\nStrictly, your variable names can also begin with an underscore. However, there is a convention among Python programmers that this is done to signal to other programmers (and code editors) that the variable is ‘private’ or intended to be hidden in some way.\nThe computer doesn’t care what name you use. However, humans who have to look at your program will be much happier if you use names that describe what the quantity ‘means’. The computer will treat these two examples identically:\nWhich one do you find easier to understand ?\nYou may encounter code that looks more like (1) than (2). This is because early programming languages placed strict limits on the length of variable names (see this wikipedia article). However, there is no longer any need for this and (we think) you should avoid it at all costs !\nAs you may have noticed from the above example, once we have set the value of a variable, we can use it in calculations. Thus,\nwill perform the calculation \\((3\\times 2) = 6\\), and display the answer on the screen. If we wish, we can choose to assign the result to another variable, e.g.\nNow, z contains the value 4. We can also reassign the value of a variable,\nNotice that x appears on both sides of the equals sign here. This should be read as ‘do the calculation x + y and then store the result in x (over-writing whatever was there before)’. We end up with x containing the value \\(3 + 2 = 5\\).",
    "crumbs": [
      "**Basic Language Skills**",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Variables</span>"
    ]
  },
  {
    "objectID": "Basics/Ex2-Variables.html#using-variables",
    "href": "Basics/Ex2-Variables.html#using-variables",
    "title": "Variables",
    "section": "",
    "text": "x = 3\ny = 2\nprint(x * y)\n\nx = 3\ny = 2\nz = x*y - y\n\nx = 3\ny = 2\nx = x + y\n\n\n\n\n\n\n\nExercise 1 - Setting, resetting and viewing variables\n\n\n\n\n\nTry creating some variables, and using them in simple calculations. Start with the examples above. Be sure to check that the results match what you expect.\nConstructs such as x = x + y are so common that Python has a special shorthand notation for this. We can express the same equation by entering x += y. There are similar versions for other operators: -=, *= and /=.\nTry out these shorthand operators. Is x += 3 the same as 3 += x? Why / why not ?\nThere is no particular advantage to using these short forms, except convenience and readibility.",
    "crumbs": [
      "**Basic Language Skills**",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Variables</span>"
    ]
  },
  {
    "objectID": "Basics/Ex2-Variables.html#naming-conventions",
    "href": "Basics/Ex2-Variables.html#naming-conventions",
    "title": "Variables",
    "section": "Naming Conventions",
    "text": "Naming Conventions\nYou can call your variables anything you like. However, following a few conventions will improve the clarity of your code:\n\nIf your variable name is made up of multiple words, either:\n\nJoin them using underscores (e.g. a_long_variable_name = 17), or\nCapitalize the first letter of each word (e.g. AnotherLongVariableName = 23.6). This is sometimes referred to as ‘camel case’ or ‘CamelCase’(since it is lower case with extra humps!).\n\nIt is common but not compulsory to use UPPER CASE for constants that should never need to be changed within the program, e.g. GRAVITATIONAL_ACCELERATION = 9.81.\nTraditionally, variables that contain integers have names beginning with the letters i, j, k, l, m, or n; variables containing real numbers start with any other letter. This comes from early programming languages (especially Fortran) where it was a requirement, and follows a similar convention in mathematics. Nowadays, this convention is often ignored for long variable names. However, if your name only contains one or two characters (e.g. a or ix), it is usual to choose the first letter appropriately. In particular, a bare i, j, k, m or n should only be used for a counting index (more on that later). If you ignore this rule, the program will work fine, but you can expect anyone who has to decipher your code in future to get more than a little bit frustrated with your choices.\n\nSome other tips:\n\nIf your code is connected to another document (e.g. you are trying to plot some equation from a paper) then use clearly-related names in both. For example, if your paper has the equation \\(y = \\alpha x +3\\gamma\\), then use the variable names x, y, alpha and gamma in your code. You can even use unicode.\nMake your variable names long enough to be clearly understood, but not too long. At most, you probably want it to be based on two or three words.\nDo not give your variable a name that has a special meaning in Python (e.g. int or sum). Doing so will not always cause problems, but it is a common source of grief.\n\nAbove all, try and develop a consistent style, and name similar quantities in similar ways. For example, the following are individually all reasonable choices for variable names:\nmass_of_helium = 4.003\nneon_mass = 20.180\nmassArgon = 39.948\nmKrypton = 83.798\nmXe = 131.293\nHowever, mixing the different styles within one program is guaranteed to cause you confusion and lead to errors. Pick one format that makes sense to you, and stick with it.\n\nTypes\nAny and every variable has a type. We can ask Python to report on the type of a given variable by using the command type(variable_name). For example,\na = 3\ntype(a)\nwill print int (shorthand for ‘integer’), while\na = 3.0\ntype(a)\nwill print float (i.e., floating-point). We will encounter other types in due course.\n\n\n\n\n\n\nExercise 2 - Variables and their types\n\n\n\n\n\nTry creating some variables, and using them in simple calculations. Start with the examples above. Be sure to check that the results match what you expect.\nWhat happens if you mix different types, ?\ni = 2\na = 3.0 * i\nprint(type(i), type(a))\nprint(a)\n\nprint(i / 2)\nprint(i / 3)",
    "crumbs": [
      "**Basic Language Skills**",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Variables</span>"
    ]
  },
  {
    "objectID": "Basics/Ex2-Variables.html#application-salary-calculations",
    "href": "Basics/Ex2-Variables.html#application-salary-calculations",
    "title": "Variables",
    "section": "Application: Salary calculations",
    "text": "Application: Salary calculations\nLet’s try doing a real-world calculation. Suppose your annual salary is $ 164,402, and the annual tax rate is 35%. How much money should be paid into your bank account every two weeks?\nWhat if you happened to be a famous musician in 1960s London, where the tax rates were more progressive. Suppose you earn $1,987,231.20 and the tax rate is just 20% on the first $50,000 that you earn, and 95% on the remainder.\n\n\n\n\n\n\nExercise 3 - Taxman\n\n\n\n\n\nCalculate your fortnightly pay as a non-musical researcher Remember, break the problem down into individual steps, and create variables for each of the quantities involved! You should find the answer is $ 4110.06.\nNow repeat the calculation for the higher-income scenario. Wait, isn’t that the same ?\n  Let me tell you how it will be\n  There’s one for you, nineteen for me\n  ’Cause I’m the taxman\n  Yeah, I’m the taxman\n  Should five percent appear too small\n  Be thankful I don’t take it all\n  ’Cause I’m the taxman\n  Yeah, I’m the taxman\n\n  Taxman George Harrison, Revolver\n\n\n\n\n\n\n\n\n\n\nVariables are more than just variables\nAs we saw earlier, each variable we create has a type. Most variables come with certain functions and attributes ‘attached’ to them, to perform various operations that are commonly-required for that data type. These can be accessed using a ‘dot’:\na = &lt;variablename&gt;.&lt;attributename&gt;\nb = &lt;variablename&gt;.&lt;functionname&gt;()\nFor example, if we create a complex number \\(z = 1+3i\\) (where \\(i = \\sqrt{-1}\\))\nz = 1 + 3j\nwe can then access two attributes and a function, - z.real - The ‘real part’ of the complex number - z.imag - The ‘imaginary part’ of the complex number - z.conjugate() - Function returning the ‘complex conjugate’ of z\nSimilarly, any floating-point number, v, comes with a v.as_integer_ratio() function that reports \\(a\\) and \\(b\\) such that \\(v = a/b\\). To see the full list of functions associated with any variable v, type help(v). You can also type v. and then hit the Tab key.\n\n\n\n\n\n\n\nCoding scratch space",
    "crumbs": [
      "**Basic Language Skills**",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Variables</span>"
    ]
  },
  {
    "objectID": "Basics/Ex2a-Functions.html",
    "href": "Basics/Ex2a-Functions.html",
    "title": "Functions",
    "section": "",
    "text": "Functions\nA function provides a convenient way to ‘wrap up’ code to accomplish a particular task. Once a function is written, it can (generally) be used without us needing to know anything about how it works. This is a very powerful concept, and complex programs are often made by chaining many functions together.\nIn general, a function has a well-defined set of inputs (sometimes known as the function’s ‘arguments’) and outputs (sometimes called the ‘return value’). In Python, and most other modern programming languages, a ‘function call’ looks like\nWe have already encountered a couple of functions: we have used print() and type(). These are known as ‘built-in functions’, as they are a core piece of the Python programming language. For a full list of built-ins, see this page of the official Python documentation. Other functions can be accessed by ‘importing’ them from ‘modules’ - we will learn more about this later.\nIt is easy to write your own functions. This is done by using the def command, and writing something like:\nNote that function_name, input1, output1 etc can be any name you wish to use. In general, a function definition comprises: - The keyword def, followed by - The function name, followed by - An opening parenthesis (, followed by - Zero or more input variables, followed by - A closing parenthesis ), followed by - A colon, :\nThis is all followed by an indented block of code containing zero or more lines of the form - The keyword return, followed by - Zero or more variable names (or valid expressions)\nFor example\nWe can then ‘call’ this function:\nThe variable result should now contain the value 7 (= 3 + 5 - 1).\nA few things to notice from this example: - When we ‘call’ (use) a function, we can give it both named variables (a and b), and values (-1). - The variable names we pass to the function don’t need to match the variable names used when ‘declaring’ (defining) the function - so we can use a and b instead of first and second. - The return keyword specifies what the function result will be.\nHere’s a slightly more complicated example, which calculates the sign and absolute value of the input (unless it is zero):",
    "crumbs": [
      "**Basic Language Skills**",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "Basics/Ex2a-Functions.html#functions",
    "href": "Basics/Ex2a-Functions.html#functions",
    "title": "Functions",
    "section": "",
    "text": "output1, output2 = function_name(input1, input2, input3)\n\n\ndef function_name(input1, input2, input3):\n    [code to compute outputs...]\n    return output1,output2\n\n\n\ndef addThreeNumbers(first, second, third):\n    return first + second + third\n\na = 3\nb = 5\nresult = addThreeNumbers(a, b, -1)\n\n\n\n\n\n\n\nExercise 1 - Create a python function\n\n\n\n\n\nCreate the addThreeNumbers function and try it out\n\n\n\n\n\n\n\n\n\n\n\ndef signAndValue(x):\n    if x == 0:\n        print(\"Unable to handle zero\")\n    elif x &gt; 0:\n        return +1, x\n    else:\n        return -1, -x\n\n    print(\"Hope that helps !\")\n\n\n\n\n\n\nExercise 2 - Exploring how functions work\n\n\n\n\n\nTry creating this function and see how it behaves. Some things to think about: - When is the message “Hope that helps !” printed? Why? -\nWhat form does the function result have? What is its type? What about if x has the value 0 ? - What is the role of if/elif/else? (We’ll deal with that question in the next section, but it should be clear enough)\nYou can call this function in two slightly different ways. The first is to write (for example)\nresult = signAndValue(x)\nand the second is to write\nsgn, val = signAndValue(x)\nTry both forms. What type does each result have? What happens if x is 0 ? Look again at the function declaration: can you explain this behaviour?\n\n\n\n\n\n\n\n\n\n\nFunction arguments\nThe following function calculates the sum of the integers from n0 to N, inclusive: \\(\\sum_{n=n_0}^N n\\).\ndef sumIntegers(N, n0):\n    result = 0\n    for i in range(n0, N+1):\n        result += i\n    return result\nNote that the function definition has the upper-limit, N, as the first input argument, contrary to what one might expect - the reason for this will soon become clear.\nIt might usually be the case that we want to start our sum at \\(n_0 = 1\\). Python allows us to provide this as a ‘default’ value for the n0 variable, by simply changing the function declaration:\ndef sumIntegers(N, n0=1):\n    result = 0\n    for i in range(n0, N+1):\n        result += i\n    return result\nNow, if we call sumIntegers with only one argument, it is assumed that this is N, and n0 receives its default value. However, if we provide two arguments, these are interpreted as N and n0 respectively.\nWe can have multiple arguments with default values. For example, we can extend our function to compute \\(\\sum_{n=n_0}^N n^{\\,p}\\) for some power \\(p\\):\ndef sumIntegers(N, n0=1, p=1):\n    result = 0\n    for i in range(n0, N+1):\n        result += i**p\n    return result\nIf we call this specifying one, two, or three arguments, they are assumed to occur in the same order as in the function declaration (i.e. N, n0, p). However, we can also explicitly specify which arguments we wish to set. For example\nresult = sumIntegers(10, p=2)\nwould calculate the sum of squares, leaving n0 set to its default value.\nIf inputs are not labelled, they are assumed to be provided in the same order as in the function definition. The following function displays the value of each argument: you can use it to check you understand the different ways to call a function.\ndef printArgs(a, b, c=17, d=4.3):\n    print(\"a is: \"+str(a))\n    print(\"b is: \"+str(b))\n    print(\"c is: \"+str(c))\n    print(\"d is: \"+str(d))\n\n\n\n\n\n\nExercise 3 - Optional Arguments / defaults\n\n\n\n\n\nHere is the original form of sumIntegers which you can now validate to see if it works as you expected.\nNow modify the function to have n0 be an optional argument with a default value. Does this work as you expected ? When would this behaviour be useful ?\nRun the printArgs function for these cases:\n\nprintArgs(1, 2, 3, 4)\nprintArgs(1, 2, 'a', (1,2,3) )\nprintArgs(2, 1, d=4, c=3 )\n\n\ndef printArgs(a, b, c=17, d=4.3):\n    print(\"a is: \"+str(a))\n    print(\"b is: \"+str(b))\n    print(\"c is: \"+str(c))\n    print(\"d is: \"+str(d))\n\nModify the printArgs function to return the type as well as the value of each argument. Does the default definition set the type ?\n\n\n\n\n\n\n\n\n\nNote that the printArgs() function above does not contain an explicit return statement. It is an example of a function that has ‘side-effects’: it does something that isn’t apparent from knowledge of its outputs. Sometimes, it is necessary to write code with side-effects, especially for data input or output. However, they are a common source of problems, and they should be avoided where possible.\n\n\nScope of variables in functions\nWhen you pass a variable to a function, you effectively create a copy of the information it contains (unless it is a ‘list’ or ‘array’ - more on those in a later exercise!). Changing the variable within the function does not change the value outside the function, unless you pass it back via an output. For example:\ndef increment(x):\n    x += 1\n    print(\"Inside increment, x is now \"+str(x))\n    return x\n\nx = 0\n\nincrement(x) # Notice that we don't do anything with the return value here\nprint(x)      # x will therefore still be zero\nx = increment(x) # This time we are updating the value of x\nprint(x)      # x will be one.\n\n\n\n\n\n\nExercise 4 - Variables within functions\n\n\n\n\n\nTry this out, and check you understand what’s going on.\n\ndef increment(x):\n    x += 1\n    print(\"Inside increment, x is now \" + str(x))\n    return x\n\n\nx = 0\nincrement(x)  # Notice that we don't do anything with the return value here\nprint(x)\n...\n\nTry this version of the `increment` function\n\ndef increment():\n    global x\n    x += 1\n    print(\"Inside increment, x is now \" + str(x))\n    return x\n\nIf you leave out the global x then x will be undefined in the function as it does not have access to outside variables.\n\n\n\n\n\n\n\n\n\nThere is a way to access external (global) variables from within functions. They might be used in this situation:\n\nsystem_is_setup = False\n\n\ndef setup():\n    global system_is_setup\n    if system_is_setup == False:\n        # Do system setup tasks\n        ...\n    else:\n        # check system is ok\n        ...\n\n    return\n\nGenerally speaking, functions using global variables in this way is a poor choice of implementation because some hidden code is modifying the global state without us, as users, being in control or even aware. We do often define variables of this nature when we use python objects that have a special internal (private) state. We will learn about this later.\n\n\nFunction documentation\nTo allow anyone to use your function without knowing the details, you need to document it. This appears in the code just after the definition of the function (and other python entities too). This step may seem unimportant at first, but is critical for re-using your code and distributing it to other people ! Another way is to just call help(&lt;functionname&gt;) and it will output the documentation.\n\nhelp(print)\n\n    Help on built-in function print in module builtins:\n\n    print(\\*args, sep=' ', end='\\n', file=None, flush=False)\n        Prints the values to a stream, or to sys.stdout by default.\n\n    sep\n        string inserted between values, default a space.\n    end\n        string appended after the last value, default a newline.\n    file\n        a file-like object (stream); defaults to the current sys.stdout.\n    flush\n        whether to forcibly flush the stream.\nDocumentation is provided by writing ‘docstrings’ at the start of any function you create. These consist of blocks of text enclosed in triple inverted commas:\n\"\"\"[Documentation goes here...]\"\"\"\nIn scientific Python, docstrings usually follow a certain style, e.g.:\ndef increment(x):\n    \"\"\"increment x.\n\n    Parameters\n    ----------\n    x : integer\n        the number you want to increament\n\n    Returns\n    -------\n    x : integer\n        incremented x\n    \"\"\"\n    x += 1\n    print(\"Inside increment, x is now \"+str(x))\n    return x\n\n\n\n\n\n\nExercise 4 - Documentation of a function\n\n\n\n\n\nCheck how the documentation string for the increment function works: try changing the documentation to see what happens. Do spaces matter ? Does it matter if the docstring is positioned exactly by the def increment(x): line ?\nNow do the same for the sumIntegers function taking care to indicate default values and what they mean.\n\n\n\n\n\n\n\n\n\n\n\nSandbox\n\n\n\n\n\n\nCoding scratch space",
    "crumbs": [
      "**Basic Language Skills**",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "Basics/Ex3-Conditionals.html",
    "href": "Basics/Ex3-Conditionals.html",
    "title": "Conditional expressions",
    "section": "",
    "text": "Summary\n\n\n\nIn this section we introduce conditional execution which allows us to write algorithms that change their behaviour depending on the nature of the inputs provided.\n\n\nConditional expressions allow us to alter the behaviour of our program depending on the circumstances. To do this, we employ an if...elif...else construct, which takes the form:\nif &lt;condition&gt;:\n    [...]\nelif &lt;another condition&gt;:\n    [...]\nelse:\n    [...]\nHere, each &lt;condition&gt; is a ‘logical’ expression - something which is either ‘true’ or ‘false’. Each [...] denotes a block of code that is only executed if the condition is met. We can have as many elif (‘else if’) blocks as we wish, and we can omit the elif and/or else blocks entirely. At most, one block will be executed: each is tried in the order they appear in the program, until one is found for which &lt;condition&gt; is True. Notice that the else block does not have a condition - this is executed if none of the other conditions are met.\nTo make this clearer, here’s a real example, inside a function:\ndef condExample(x):\n    if x&lt;0:\n        print(\"x is negative\")\n    elif x&lt;=1:\n        print(\"x is between 0 and 1 (inclusive)\")\n    else:\n        print(\"x is greater than 1\")\n\n\n\n\n\n\nExercise 1 - if / elif / else\n\n\n\n\n\nTry this function. Does everything behave as you would expect? Try deleting the elif and/or else clauses; how does this affect the output ?\n\n\n\n\n\n\n\n\n\n\nLogical expressions\nLogical expressions are calculations that result in either True or False. As we have already seen, they often arise by comparing the value of two variables (or a variable and a constant), such as x &gt; 0. The comparison operators are:\n\n\n\nOperator\nMeaning\n\n\n\n\n&gt;\nGreater than\n\n\n&lt;\nLess than\n\n\n&gt;=\nGreater than or equal to\n\n\n&lt;=\nLess than or equal to\n\n\n==\nEqual to\n\n\n!=\nNot equal to\n\n\n\nYou can check you understand how these work by testing expressions in a Python cell: for example, entering\n3 &gt; 5\nshould evaluate to False.\nNote: an important point is that the constants True or False are Booleans, and not text. So \"True\" (string) is very different of True (Boolean). A possible mistake is to confound them and use \"True\" instead of True. In general, as soon as you want to use something based on a true/false behavior, use Boolean constants in your program.\nTo build more complicated expressions, you can use the Boolean operators and, or and not. An expression of the form A and B is only True if both A and B are separately True. On the other hand, A or B is True if either (or both) of A and B are themselves True. The not operator flips True to False, and vice versa. You can use parentheses to group expressions if necessary.\nFor example:\nx &gt; 3 and (y == 2 or not (y &gt; 3 and x+y ==4) )\nMany logical conditions can be expressed in multiple forms, for example x &gt; 3 is identical to not x &lt;= 3. In general, you should use the simplest form that is appropriate to your circumstances.\nN.B. In some other languages, the symbols & and | are used for and and or. In Python, these symbols are ‘bitwise’ operators, and they will not give the results you expect. We will avoid using them in this course.\n\n\n\n\n\n\nExercise 2 - &lt;, &gt;, ==\n\n\n\n\n\nTest each of the operators to see if they work as expected. Be careful with the == in real programs x==3 returns True or False but, if you make a typo, x=3 will change x quietly (but 3==x is a valid test, 3=x is a SyntaxError)\nTry using the and, or and not operators.\n\n\n\n\n\n\n\n\n\n\n\nTesting for None\nAnother logical operator you may encounter is is. This is used to test whether two variable names refer to the same entity. This is stronger than simply testing for equality. For example:\na = 300\nb = 300\nprint(a is b)\nprint(a == b)\na is b will return False, whereas a is a returns True. This may seem like a pointless detail, but we can define the == and is differently for complicated data structures and objects.\nIt can also be useful to distinguish between a value that has not been set, and a value that is False or 0 etc. where the logical tests may produce unexpected positives. You will often see a null default value within a function:\ndef printHello(name=None):\n    if name is None:\n        print(\"Hello, what is your name?\")\n    else:\n        print(\"Hello \"+name)\n\n\n\n\n\n\nCoding scratch space",
    "crumbs": [
      "**Basic Language Skills**",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Conditional expressions</span>"
    ]
  },
  {
    "objectID": "Basics/Ex4-Loops.html",
    "href": "Basics/Ex4-Loops.html",
    "title": "Loops",
    "section": "",
    "text": "Summary\n\n\n\nIn this section we introduce loops that allow repeated execution of an algorithm with a defined series of input values.\n\n\nMuch of the power in programming comes from being able to repeat calculations, and change how our program works depending on the values of certain variables along the way. To achieve this, we need to employ ‘loop expressions’ and build on our use of ‘conditional expressions’.\nLoops allow you to repeat a series of calculations a number of times, or until certain conditions are met. In Python, there are two main loop formats.\n\nThe while loop\nThe first is a while loop:\nwhile &lt;condition&gt;:\n    [...]\nHere, &lt;condition&gt; is a logical expression (just like those discussed above). If this evaluates to True, the block of code ([...]) is executed in its entirety. The condition is then evaluated again, and the entire process repeats until it becomes False. For example, here is a loop that keeps doubling a number until it exceeds some threshold:\nx = 1\nwhile x&lt;100:\n    x += x\nprint(x)\nNormally, the entire indented block of code below the while statement is executed before the condition is checked again. However, two commands can be used to alter this:\n\nThe break keyword terminates the loop, jumping to the first statement after the indented block\nThe continue keyword skips over any remaining code within the indented block, but returns to re-evaluate the &lt;condition&gt;, and if this is True will execute the indented block as before.\n\nThese two commands are almost invariably used in conjunction with an if statement.\nFor example:\nx = 1\nwhile x &lt; 100:\n    x+=5\n    if x == 71:\n        break\n    if x%2 == 0:\n        continue # Skip even values of x\n    print(\"In loop: x=\", x)\n\nprint(\"After loop: x=\", x)\nIf you run this code, you will see that it never prints an even number (since the print statement is after the continue in this case, and so doesn’t get executed); moreover, the loop terminates at x=71, due to the break statement.\n\n\n\n\n\n\nExercise 1 - While loop\n\n\n\n\n\nTry the while loop example above and modify to see how it works\nWhen you run the while loop code above, you will see that it never prints an even number (since the print statement is after the continue in this case, and so doesn’t get executed); moreover, the loop terminates at x=71, due to the break statement.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nInfinite loops\n\n\n\n\n\nInfinite loops can occur if you have no break statement or explicity exit condition.\nInfinite loops will run endlessly if not manually stopped (by sending a termination signal), and are a well known problem since the dawn of computer programming. You will waste a lot of energy if you let the computer spin its wheels this way.\n\n\n\n\n\nBreaking to exit a loop\nSometimes, it may be appropriate to use the following style:\nwhile True:\n    [...]\n    if &lt;condition&gt;: break\n    [...]\nHere, the loop condition is always True, creating an infinite loop. However, the use of a break allows us to escape from the loop.\n\n\n\n\n\n\nExercise 2 - problem solving (i)\n\n\n\n\n\nSuppose you start with an empty basket and you want to pick apples on a tree. You will make 100 picking moves.\nYou start by picking 2 apples at a time, but after doing this 50 times you get bored. You then pick 5 apples each time, and after doing this a further 25 times, you start picking 10 apples.\nWrite a function containing a loop to return the number of apples in your basket after each pick\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise 3 - problem solving (ii)\n\n\n\n\n\nSuppose you take out a $500,000 mortgage to buy a house. You make a repayment of $2,000 each month. However, each month the bank charges interest at a rate of 0.3% of the outstanding balance. How many months will it take you to pay off the debt? How much does it cost you?\nWrite a function to calculate this information for any loan amount, interest rate and monthly repayment. Print the amount outstanding each month\n\n# Exercise 3 - template answer for the function\n\nloan_amount = 500000.00\n\ndef function_repayments(loan_amount, monthly_interest_rate, monthly_replayment):\n    \"\"\"This function ...\"\"\"\n    ...\n\n    return total_number_of_months\n\n# Test it based on your\n\nif function_repayments(500000, 0.3, 2000) != 460:\n    print(\"There is a problem ... \")\n\nhelp(function_repayments)\n...\n\n\n\n\n\n\n\n\n\n\nNote: there are other loops that we can use in python (e.g. the for loop) and we will see these later.\n\n\n\n\n\n\n\nCoding scratch space",
    "crumbs": [
      "**Basic Language Skills**",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Loops</span>"
    ]
  },
  {
    "objectID": "Basics/Ex5-ListsEtc.html",
    "href": "Basics/Ex5-ListsEtc.html",
    "title": "Lists, tuples and dictionaries",
    "section": "",
    "text": "Lists\nSo far, all our variables have been single numbers. However, many types of data may consist of more than one piece of information. For example, an experiment might generate measurements of pressure and temperature, each recorded at a number of different times. While it would be possible to define new variables for each number separately, it quickly becomes difficult to keep track of them all. Ideally, we would like to have a structured way of storing related information. Lists, tuples and dictionaries are some of the tools that Python provides for doing this.\nA list is defined by using square brackets, [ and ], and consists of some set of entries separated by commas, e.g.,\nThe individual entries do not need to have the same type. Also, we can have lists inside lists, e.g.,\nalthough in practice, list elements tend to be more homogenous than the example above.\nWe can access individual entries in the list by adding an index to the variable name. In Python, we have to remember a quirk: when counting objects, we start from 0 rather than from 1; this is because Python is a 0-based programming language. Thus, to access the first entry in the list a, we use a[0]; the second entry is a[1]. We can use these entries in calculations.\nThus:\nWhere an entry in a list is itself a list, we can use a second index to access the elements of this:\nNegative indices count from the last element in the array, which is accessible as a[-1].\nWe can also ask for a range of entries. To do this, we specify the index of the first entry we want, and an index one larger than that of the last entry we want, separated by a colon:\nAgain, this is somewhat quirky. However, it does mean that if we want to extract n entries starting at index i0, we simply need to ask for a[i0:i0+n]. By default, we get every element in the requested range. However, if we only want every \\(k\\)-th element, we can specify k after a second colon, .e.g,\nFinally, we can use shorthands such as a[:4] (everything from the start up to element a[3], inclusive), a[3:] (everything from a[3] to the end) and a[::2] (every second element, starting with a[0]).\nWe can change the values stored within an element of a list:\nLists are therefore said to be ‘mutable’. However, note that we need to explicitly change the list entry:\nUnlike most other variables in Python, a list variable stores a reference to the list, rather than the list itself. This means that two different variable names can refer to the same memory address, and is a common (and counter-intuitive) source of errors. For example\nNotice that the list referred to by a has changed, even though we have not explicitly altered it! This behaviour is different from ‘normal’ variables.\nIf you wish to create a copy of a list, you will need to use the ‘copy’ function:\nIf we ‘add’ two lists together, we create a new list containing the elements from each:\nOne can ‘grow’ a list:\nHowever, if you need to build a large list, this is a very inefficient way of doing it, and your program will probably end up being very slow.\nPython provides a number of standard functions for working with lists. A few of the more important ones are detailed below, where we suppose a is a list:",
    "crumbs": [
      "**Basic Language Skills**",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Lists, tuples and dictionaries</span>"
    ]
  },
  {
    "objectID": "Basics/Ex5-ListsEtc.html#lists",
    "href": "Basics/Ex5-ListsEtc.html#lists",
    "title": "Lists, tuples and dictionaries",
    "section": "",
    "text": "a = [3, 4, 5]\n\na = [3.2, 'hello', [4, 8, 17.1]]\n\n\n\na = [3.2, 'hello', [4, 8, 17.1]]\nprint(a[0])                  # Prints '3.2'\nprint(a[1])                  # Prints 'hello'\nprint(a[2])                  # Prints '[4, 8, 17.1]'\nprint(2+a[0])                # Prints '5.2'\n\na = [3.2, 'hello', [4, 8, 17.1]]\nprint(a[2])                 # Prints '[4, 8, 17.1]'\nprint(a[2][0])              # Prints '4'\nprint(a[2][1]**2 - a[2][2]) # Prints '46.9'\n\n\na = [5, 6, 7, 8, 9]\nprint(a[1:3])               # Prints [6, 7]\n\na = [5, 6, 7, 8, 9, 10, 11, 12]\nprint(a[1:6:2])             # Prints '[6, 8, 10]'\n\n\na = [1, 2, 3]\nprint(a[1]) # Prints '2'\na[1] = 17\nprint(a) # Prints '[1, 17, 3]'\n\nx = 3\na = [1, 2, x]\nprint(a) # Prints '[1, 2, 3]'\nx = 5\nprint(a) # Still prints '[1, 2, 3]'\n\n\n\n\n\n\nExercise 1 - Do you understand lists ?\n\n\n\n\n\nCheck the examples given above\n\n\n\n\n\n\nWrite a loop to populate a list with a sequence of numbers. Write a second loop to create another list which has the square of each number but in reverse order from the first one\nDon’t forget to validate your results. Write a check to ensure the first and last entries of the list are correct.\n\n\n\n\na = [1, 2, 3]\nb = a # 'a' and 'b' both refer to the same object\nprint(a)     # Prints '[1, 2, 3]'\nb[1] = 17\nprint(a)     # Prints '[1, 17, 3]'\n\n\n\n\n\n\n\nExercise 2 - lists passed to functions\n\n\n\n\n\nBecause lists are stored as references to data, changes to a list made in a function call are global. Demonstrate that this is true\n\n\n\n\n\n\nNow you know - be careful !\n\n\n\n\na = [1, 2, 3]\nb = a.copy()\nb[1] = 17\nprint(a)     # Prints '[1, 2, 3]'\n\na = [1, 2, 3]\nb = [4, 5, 6]\nprint(a + b) # Prints '[1, 2, 3, 4, 5, 6]'\n\na = [1, 2, 3]\na += [4]\nprint(a)     # Prints '[1, 2, 3, 4]'\n\n\n\nlen(a) returns the length of a, i.e. the number of elements it contains,\nmax(a) returns the largest element of a,\nmin(a) returns the smallest element of a,\nsum(a) returns the sum of the elements of a,\na.sort() sorts the elements of a,\na.append(x) adds a new element at the end of the listw, containing the contents of x,\na.insert(i, x) adds a new element containing x at location `a[i]``, shifting later elements ‘backwards’ by one,\na.remove(x) finds the first occurrence of x in the list and removes it,\na.count(x) counts the number of occurrences of x in the list,\na.index(x) returns the index of the first occurrence of x in the list,\na.reverse() flips the order of elements in a list, and\na.pop(i) removes and return the element at index i in the list (or if no argument is provided, the last element in the list).\n\n\n\n\n\n\n\nExercise 3 - functions that work on lists\n\n\n\n\n\nTry these out! Explore how each of the functions works. Remember, you can get information about any function by typing help(function_name)\n\n\n\n\n\n\nUse this block to get help on the list methods",
    "crumbs": [
      "**Basic Language Skills**",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Lists, tuples and dictionaries</span>"
    ]
  },
  {
    "objectID": "Basics/Ex5-ListsEtc.html#tuples",
    "href": "Basics/Ex5-ListsEtc.html#tuples",
    "title": "Lists, tuples and dictionaries",
    "section": "Tuples",
    "text": "Tuples\nA tuple is rather similar to a list, but is defined using round brackets, ( and ), e.g.,\na = (3, 'x', (1, 2, 3))\nAgain, tuples can contain multiple elements, and the elements may not all share the same type. The key difference is that tuples are immutable, so that once a tuple is created it cannot subsequently be changed. (It can be extended – but this is effectively the creation of a new, larger tuple!) As with lists, the individual elements of a tuple can be accessed using [index] after the tuple name, e.g.\na = (3, 4, 5)\nprint(a[1]) # Prints `4`\nAgain, Python provides a number of functions for working with a tuple (‘a’), including:\n\nlen(a)\nmin(a)\nmax(a)\na.index(x)\na.count(x)\n\nall of which are similar to their counterparts for lists.\n\n\n\n\n\n\nExercise 4 - functions that work on tuples\n\n\n\n\n\nTry these out! Explore how each of the tuple functions and methods works. Remember, you can get information about any function by typing help(function_name)\n\n\n\n\n\n\nUse this block to get help on the tuple methods\n\n\n\n\n\n\n\n\n\nA tuple can be converted into a list, and vice versa:\na = [3, 4, 5]\nb = (6, 7, 8)\nta = tuple(a)\nlb = list(b)\nWhen should you use a tuple, and when should you use a list? To some extent, this is a matter of style and preference. In general, the advice is that all the entries in a list should be ‘the same kind of data’, whereas the entries in a tuple are likely to represent different entitites. For example, if we have an experimental dataset that consists of observations of pressure and temperature at a sequence of time points, it might be appropriate to represent each observation as a tuple of (pressure, temperature), and then the sequence of observations as a list of these tuples [(p1, T1), (p2, T2), (p3, T3),...].\nThere is a key difference between tuples and lists, though. An immutable data type can be used as a key in a dictionary. So we can use a tuple as a tag for other kinds of data. We haven’t explored what a key for a dictionary means, so let’s do that now.",
    "crumbs": [
      "**Basic Language Skills**",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Lists, tuples and dictionaries</span>"
    ]
  },
  {
    "objectID": "Basics/Ex5-ListsEtc.html#dictionaries",
    "href": "Basics/Ex5-ListsEtc.html#dictionaries",
    "title": "Lists, tuples and dictionaries",
    "section": "Dictionaries",
    "text": "Dictionaries\nDictionaries provide a mechanism for storing data labelled with a keyword or other information. To create a dictionary, we use curly brackets, and associate each piece of data with a label:\na = {&lt;label1&gt;: &lt;data1&gt;, &lt;label2&gt;: &lt;data2&gt;}\nAnother syntax to create dictionaries is:\na = dict(&lt;label1&gt;=&lt;data1&gt;, &lt;label2&gt;=&lt;data2&gt;)\nFor example, if we wished to store an object’s mass, location and length, we might create a dictionary as follows:\na = {'mass': 17.3, 'length': 0.7, 'location': (3, 1, 8)}\nor\na = dict(mass=17.3, length=0.7, location=(3, 1, 8))\nNote that in this example, the location key is storing a tuple. This illustrates that you can store many things in dictionaries, including arrays, list, tuples or objects for instance.\nNow, we can use the keywords as an index:\nprint(a['mass'])\nprint(a['length'])\ninertia = 0.5 * a['mass'] * a['length']**2\nprint(inertia)\nOften keywords will be text strings, but they do not need to be:\ny = (3, 4, 5)\na = {2: '13.5', y: [6, 7, 8]}\nprint(a[2])\nprint(a[y])\nYou can add new entries to a dictionary by simply assigning to the indexed entry you wish to create:\na = {'name': 'Bob'}\nprint(a['name']) # Prints 'Bob'\n# print(a['age']) would not work at this point\na['age'] = 28\nprint(a) # Now contains both 'name' and 'age'.\nAgain, Python provides a number of functions that work with dictionaries, many of which we have already encountered, including: - len(a) - max(a) - min(a) - a.copy() - a.pop()\nSome methods particular to dictionaries are: - a.keys() - returns a list-like object containing all the ‘labels’ within the dictionary a, - a.values() - returns a list-like object containing all the ‘values’ within the dictionary a, and - a.items() - returns a list-like object containing (label, data) tuples for each of the entries in the dictionary.\n\n\n\n\n\n\nExercise 5 - functions that work on dictionaries\n\n\n\n\n\nTry these out! Explore how each of the dictionary functions and methods works. Remember, you can get information about any function by typing help(function_name)\nTry making a dictionary with keys that are not strings. In particular, try a tuple, try a list, try a floating point number.\n\n\n\n\n\n\nUse this block to get help on the dictionary methods\n\n\n\n\n\n\n\n\n\nDictionaries provide a useful mechanism for storing miscellaneous, unstructured information, such as metadata. The use of human-readable labels makes it easy to remember what each entry represents.\nSome properties of the first few elements in the periodic table are given below. Melting and boiling points are determined at atmospheric pressure.\n\n\n\n\n\n\n\n\n\n\nElement\nSymbol\nAtomic Number\nMelting point (K)\nBoiling point (K)\n\n\n\n\nHydrogen\nH\n1\n14\n20\n\n\nHelium\nHe\n2\n1\n4\n\n\nLithium\nLi\n3\n453\n1603\n\n\nBeryllium\nBe\n4\n1560\n2742\n\n\nBoron\nB\n5\n2349\n4200\n\n\nCarbon\nC\n6\n3915\n3915\n\n\nNitrogen\nN\n7\n63\n77\n\n\nOxygen\nO\n8\n54\n90\n\n\nFluorine\nF\n9\n53\n85\n\n\nNeon\nNe\n10\n25\n27\n\n\n\n\n\n\n\n\n\nExercise 6 - Dictionary as data frame (i)\n\n\n\n\n\nCreate a dictionary to store this information, indexed by the symbol. Then write a function which allows the user to specify an element (via its symbol) and a temperature, and which reports whether the element is solid, liquid or gas at that point.\n\n\n\n\n\n\n\n\n\nIn a previous exercise, you wrote code to calculate mortgage repayments. Different banks are offering different interest rates, with special introductory rates for the first two years of the mortgage:\n\n\n\nBank name\nYears 1 & 2\nYear 3 onwards\n\n\n\n\nANZ\n2.3%\n4.1%\n\n\nBank of Australia\n0.1%\n5%\n\n\nCommonwealth Bank\n3.5%\n3.8%\n\n\nWestpac\n3.7%\n3.7%\n\n\n\n\n\n\n\n\n\nExercise 7 - Dictionary as data frame (ii)\n\n\n\n\n\n➤ Use a dictionary to store this information, and modify your function so that the user can specify which bank provides their mortgage. You can assume that the monthly payment rate is simply one-twelfth of these annual total payment (i.e. the repayments do not account for the reduced principal over the year).",
    "crumbs": [
      "**Basic Language Skills**",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Lists, tuples and dictionaries</span>"
    ]
  },
  {
    "objectID": "Basics/Ex5-ListsEtc.html#sets",
    "href": "Basics/Ex5-ListsEtc.html#sets",
    "title": "Lists, tuples and dictionaries",
    "section": "Sets",
    "text": "Sets\nFinally, we briefly mention the set data type. This is not commonly encountered, but can be very useful. It implements the mathematical concept of a set, an unordered collection of unique objects. A set can be created from a tuple or list:\na = [3, 4, 5]\ns = set(a)\nprint(s) # prints {3, 4, 5}\nDuplicates are ignored:\na = [3, 3, 5]\ns = set(a)\nprint(s) # prints {3, 5}\nWe can test whether one set is a subset of another set (that is, whether every element of the first set is also in the second) using the &lt;,&gt;, &lt;= and &gt;= operators:\nset([3, 4]) &lt; set([3, 4, 5]) # True\nset([3, 4, 5]) &lt; set([3, 4, 5]) # False\nset([3, 4, 5]) &lt;= set([3, 4, 5]) # True\nWe can find the union of two sets - the set of all elements in either set - using the | operator, and the intersection - all elements shared between the sets - using the & operator:\na = set([3, 4])\nb = set([4, 5, 6])\n\nprint(a | b) # prints {3, 4, 5, 6}\nprint(a & b) # prints {4}\nWe can also use the operator - to remove the elements of one set from another set.\na = set([3, 4])\nb = set([4, 5, 6])\n\nprint(b - a) # prints {5, 6}\nprint(b^a) # prints {3, 5, 6}\nThere is also a ^ operator, which is defined such that a^b is equivalent to (a|b) - (a&b).\n\n\n\n\n\n\nExercise 8 - Do you understand sets ?\n\n\n\n\n\nCheck the examples given above to make sure you have some experience of what the set construct is within python.\n\n\n\n\n\n\n\n\nSandbox\n\n\n\n\n\n\nCoding scratch space",
    "crumbs": [
      "**Basic Language Skills**",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Lists, tuples and dictionaries</span>"
    ]
  },
  {
    "objectID": "Basics/Ex6-MoreLoops.html",
    "href": "Basics/Ex6-MoreLoops.html",
    "title": "More about loops",
    "section": "",
    "text": "Summary\n\n\n\nIn this section we go deeper into the concept of loops with the concept of a for loop and discuss the concept of an iterable object (a python object that returns a sequence of values one after the other when asked).\n\n\nWe have already encountered one way of repeating calculations - the while loop. Python also provides a second kind of loop, the for loop. This allows us to do a calculation for each of the entries in a list, tuple or dictionary (or, more generally, any object that can yield a well-defined return value each time it is called).\n\nThe For loop\nTypically, a for loop takes the form:\nfor &lt;variable&gt; in &lt;collection&gt;:\n    [calculations using &lt;variable&gt;]\nAs with the while loop, everything within the indented block is executed multiple times, with the &lt;variable&gt; getting set equal to a different element of &lt;collection&gt; on each pass. &lt;collection&gt; may be any ‘iterable’, such as a list. For example, the following code would calculate the sum of all the entries in a:\na = [1, 5, 9]\ns = 0\nfor x in a:\n    s += x\n    print(x, s)\nprint(\"Total is:\", s)\nIt is possible to use continue [go to the next iteration immediately] and break [terminate the loop immediately] statements within a for loop, just as in a while loop.\nOften, we simply want to perform a calculation \\(n\\) times, counting off as we go. To allow this, Python provides the range function, which is a special kind of iterable. It can be used as follows:\nn = 20\nfor i in range(n):\n    print(i)\nBy default, the counting starts from 0, and continues up to \\(n-1\\) (so that there are a total of \\(n\\) passes through the loop). If you want to start from a different number, you can provide this:\nistart = 3\nistop = 15\nfor i in range(istart, istop):\n    print(i)\nNotice that the counting starts with istart, and finishes with istop-1. We can also count in increments of istep:\nistart = 3\nistop = 15\nistep = 4\n\nfor i in range(istart, istop, istep):\n    print(i)\nThis will print istart, istart + istep, istart + 2*istep etc, but not any value equal to or greater than istep.\n\n\n\n\n\n\nExercise 1 - Try out the for loop\n\n\n\n\n\nRewrite our previous while loop test-case as a for loop. Note that the full syntax of the range function is range(start, end, step) which allows you to skip by 5 as we previously did. You may need to read the help and try the examples above.\nx = 1\nwhile x &lt; 100:\n    x+=5\n    if x == 71:\n        break\n    if x%2 == 0:\n        continue # Skip even values of x\n    print(\"In loop: x=\", x)\n\nprint(\"After loop: x=\", x)\n\n\n\n\n\n\n\n\n\n\n\nA loop to calculate \\(\\pi\\)\nThe value of \\(\\pi\\) can be found via an infinite sum \\(\\pi = 2 \\sum_{k=0}^\\infty 2^k (k!)^2 / (2k+1)!\\), where \\(n!\\) denotes the factorial of \\(n\\), i.e., \\(n! = n(n-1)(n-2)\\ldots 1\\). This can be computed by initialising a variable to contain the value 1, and then looping through the integers up to n multiplying the variable by each.\n\n\n\n\n\n\nExercise 2 - \\(\\pi\\)\n\n\n\n\n\nBy summing the first \\(N\\) terms in the series, compute an approximation to \\(\\pi\\) and explore how the accuracy of the approximation changes with \\(N\\). A good starting point is \\(N = 20\\).\n\n# A series that converges to the value of $\\pi$\n\n\n\n\n\n\nenumerations\nOften, we may need to iterate through a collection of objects (such as a list), but also keep a count of how many objects we have dealt with.\nThere are various ways this could be done - one might be:\na = [3, 5, 7]\nfor i in range(len(a)):\n    print(\"Object number\", i, \" is \", a[i])\nHowever, Python provides the enumerate function for precisely this purpose:\na = [3, 5, 7]\nfor i, ai in enumerate(a):\n    print(\"Object number\", i, \" is \", ai)\nThe iterable created by enumerate returns a tuple of (index, object) pairs, which can be assigned to a pair of variables (here, i and ai).\n\n\n\n\n\n\nExercise 2 - using enumerate\n\n\n\n\n\nTry the example for enumerate (above). Check for yourself for different enumerations. For example, use range(12, 24, 3) as your iterable.\n\n# test the use of enumerate ...\n\n\n\n\n\n\nzip\nAnother common circumstance is that we have two (or more) collections, and we want to access the \\(i\\)-th element of each simultaneously. Again, this could be achieved using something like:\na = [3, 5, 7]\nb = ['a', 'b', 'c']\nfor i in range(len(a)):\n    print(\"The letter associated with \", a[i], \" is \", b[i])\nbut Python also provides the zip function for this purpose:\na = [3, 5, 7]\nb = ['a', 'b', 'c']\nfor ai, bi in zip(a, b):\n    print(\"The letter associated with \", ai, \" is \", bi)\nThis creates an iterator which returns a tuple on each iteration, containing the \\(i\\)-th element of each of the collections passed to zip. The elements of this tuple can be assigned to variables (here, ai and bi).\n\n\n\n\n\n\nExercise 3 - using zip\n\n\n\n\n\nip may be a little bit hard to understand unless you try it (and try, try, try again). Try the example and mess around until it sinks in\n\n# test the use of zip ...\n\n\nlist comprehension loops\nFinally, a for loop can be used to initialise a list. This is quite a common occurence in python code you may find online, but is hard to understand when you first see it. You will often see the following shorthand:\n&lt;list&gt; = [ &lt;expression involving variable&gt; for &lt;variable&gt; in &lt;collection&gt; ]\ne.g.\na = [i**2 for i in range(3, 13, 2)]\nThis is sometimes known as a list comprehension. A tuple can be built similarly\na = tuple(i**2 for i in range(3, 13, 2))\nand\na = {x:y for x, y in zip(['a', 'b', 'c'], [1, 2, 3])}\ncan be used to construct a dictionary.\n\n\n\n\n\n\nExercise 4 - list comprehension loop\n\n\n\n\n\nTry the examples above … they really do work even if they look quite hard to follow. Maybe you don’t feel confident writing code like this (in which case - don’t, it’s not important to do fancy things) but it is important to be able to understand what is done if you come across this idiomatic code.\n\n\n\n\n\n\n\n\n\n\n\n\nPrime numbers\nThe Sieve of Eratosthenes is a method for finding prime numbers (i.e., integers which are not divisible by any other integers except themselves and one). Suppose you want to find all the prime numbers less than or equal to 25. First, you write down a list of all the numbers from 2 up to 25:\n2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n\n\n\n\nNow, you start crossing out numbers. First, we consider the first entry in the list, 2. We keep this, but cross out every second number thereafter:\n2 3 X 5 X 7 X 9 X 11 X 13 X 15 X 17 X 19 X 21 X 23 X 25\n^Start here\nWe move our pointer to the next not-crossed-out number, 3. We then cross out every 3rd entry (counting ones that are already crossed out):\n2 3 X 5 X 7 X X X 11 X 13 X X X 17 X 19 X X X 23 X 25\n  ^Start here\nThe next not-crossed out number is 5, so we remove every 5th entry:\n2 3 X 5 X 7 X X X 11 X 13 X X X 17 X 19 X X X 23 X X\n      ^Start here\nIf we continue this procedure, we will find that we do not cross out any more numbers. The remaining numbers - 2, 3, 5, 7, 11, 13, 17, 19 and 23 - are all the primes less than (or equal to) 25.\n\n\n\n\n\n\nExercise 5 - prime number computation\n\n\n\n\n\nWrite a function that takes a single input, \\(N\\), and returns the list of all prime numbers less than \\(N\\). Hint: use the ‘sieve of Eratosthenes’ that we just told you about ! Also: use a for loop !\n\n\n\n\n\n\n\n\n\n\n\n\nSandbox\n\n\n\n\n\n\nCoding scratch space",
    "crumbs": [
      "**Basic Language Skills**",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>More about loops</span>"
    ]
  },
  {
    "objectID": "Basics/Ex7-Strings.html",
    "href": "Basics/Ex7-Strings.html",
    "title": "Strings",
    "section": "",
    "text": "String conversion\nUntil now, we have mainly been dealing with numeric data (numbers). However, it is often necessary to process text sequences, referred to as ‘character strings’. In this section, we will see some of the mechanisms Python provides for text processing. Even when we are not processing lots of text, we do need to be able to read and write the results of our work and the starting point for that is text manipulation.\nAs we have already seen, any literal text sequence can be entered between a pair of inverted commas (” ” or ’ ’), and stored to a variable. Python allows both single and double quotes to be used (not all languages do, so be careful if translating this sort of thinking to another language in the future).\nIf we look at type(name), we see that Python has a str type to represent strings.\nTo join two strings together, we can simply combine them using the + operator:\nWe can enter quotation marks in a string literal by using the other kind of quotation mark as the string delimiter: either\nWe can also ‘escape’ the quotation mark, by placing a \\ in front of it. This forces Python to treat it as a literal character, without any special meaning:\nFinally, we can use triple-quotes (““” “““) to mark the beginning and end of the string, which allows ’ and” to appear within the string without difficulties:\nWe already encountered triple-quoted strings, in the context of docstrings at the start of a function.\nWe can also use the multiplication operator to repeat a string multiple times:\nHowever, most other ‘mathematical’ operators (such as subtraction and division) have no meaning with strings.\nNote that string variables containing numbers are not the same as integer or float variables containing the same numbers:\nHowever, we can obtain an integer or float variable by using the int and float functions to convert them:\nThis only works if the string is a plausible representation of a single number. int('3 6') is assumed to correspond to two distinct numbers, and so they cannot be converted to a single integer and python does not automatically return a tuple such as (3,6). Similarly, while numbers containing a decimal point can be converted to floating-point form, they cannot be interpreted as an integer.",
    "crumbs": [
      "**Basic Language Skills**",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Strings</span>"
    ]
  },
  {
    "objectID": "Basics/Ex7-Strings.html#worked-example-caesar-cipher",
    "href": "Basics/Ex7-Strings.html#worked-example-caesar-cipher",
    "title": "Strings",
    "section": "Worked Example: ‘Caesar’ cipher",
    "text": "Worked Example: ‘Caesar’ cipher\nAs we have already discussed, every piece of information within a computer must be organised and represented in binary form. This implies that the sequence of letters in the alphabet can be mapped onto the set of integers, and this is usually done via the ‘ASCII’ code sequence.\nPython provides the function chr(integer) to convert integers into their ASCII alphanumeric equivalent.\n\n\n\n\n\n\nExercise 6 - Character manipulation\n\n\n\n\n\nWrite a loop to print the integers from 33 up to 128, and their ASCII equivalents. (The first 32 ASCII codes are special control characters, and do not have alphanumeric equivalents).\n\n\n\n\n\n\n\n\n\nA ‘Caesar cipher’ is a very simple way to hide a message making it difficult for someone to read. To encode a piece of text with a Caesar cipher, we simply shift each letter \\(N\\) places up (or down) the alphabet. For example, choosing \\(N=1\\), the message\nI like Python\nwould become\nJ mjlf Qzuipm\nbecause ‘J’ is one letter after ‘I’, ‘m’ is one after ‘l’, and so on.\n\n\n\n\n\n\nExercise 7 - Hail Caesar !\n\n\n\n\n\nWrite a function to encode messages using Caesar ciphers (for any choice of \\(N\\)). Note that the ‘decoder’ is simply the ‘encoder’, but instead using \\(-N\\).\nHere is a message encoded using a Caesar cipher:\nPfl yrmv wzezjyvu kyzj vovitzjv\nBy looping through all possible values of \\(N\\), find the \\(N\\) used to encode this message and decode it.\n\n\n\n\n\n\n\n\n\n\nOlder approaches to string formatting\n\n\n\n\n\n\nOlder format - examples\n\n\n\n\n\nThis is best illustrated by an example, using the first (older) formatting framework:\nx = 1/11\nprint(x)\ns = \"One eleventh is approximately %.3f\"\nprint(s)\nprint(s%x)\nHere, the string s contains the text we wish to produce, and the entry %.3f is a placeholder representing a floating point number with three decimal places. x is a floating point variable, calculated to many decimal places. The code s%x combines the two, resulting in the contents of x being inserted into the string s, formatted as required.\nAll placeholders begin with the ‘%’ symbol. Integer placeholders end with the letter ‘i’, floating-point placeholders end with the letter ‘f’, and string placeholders end with the letter ‘s’. Between the ‘%’ and the letter, one can specify various options controlling the exact form of output:\n\n\n\n\n\n\n\n\n\nPlaceholder\nDescription\nExample\nOutput\n\n\n\n\n%i\nGeneral integer (no further formatting specified)\n'%i'%3\n‘3’\n\n\n%3i\nInteger, at least 3 characters wide\n'%3i'%3\n'  3'\n\n\n%03i\nInteger, at least 3 characters wide, zero-padded\n'%03i'%3\n'003'\n\n\n%f\nGeneral floating-point number (no format specified)\n'%f'%2.9\n‘2.900000’\n\n\n%12f\nFloating-point number, occupying at least 12 characters\n'%12f'%2.9\n'    2.900000'\n\n\n%012f\nFloating-point number, occupying at least 12 characters, zero-padded\n'%012f'%2.9\n'00002.900000'\n\n\n%8.2f\nFloating-point number, occupying at least 8 characters, rounded to two decimal places\n'%8.2f'%2.9\n'    2.90'\n\n\n%s\nGeneral string (no format specified)\n'%s'%'test'\n'test'\n\n\n%10s\nString, occupying at least 10 characters\n'%10s'%'test'\n'      test'\n\n\n%%\nLiteral ‘%’ character\n'%6.2f%%'%2.9\n'  2.90%'\n\n\n\nWhere a string contains more than one placeholder, we can pass the required information as a tuple:\nphrase = '%i litres of %s at $%.2f/L costs a total of $%.2f'\nprint(phrase%(2, 'milk', 1.29, 2*1.29))\nprint(phrase%(40, 'petrol', 1.53, 40*1.53))\nprint(phrase%(7.5, 'water', 0.17, 7.5*0.17))\nSometimes, it may be necessary to use string formatting to write the placeholders, allowing the style of output to be set at runtime:\ndef print_result(result,number_of_decimal_places):\n    fmt = \"The result is %%.%if\"\n    print((fmt%number_of_decimal_places)%result)\nHowever, this is best avoided if possible.\n\n\n\n\n\n\nA second, newer approach to formatting uses braces {} instead of %... to represent a placeholder, and a .format() function that can act on any string. The syntax of the format specifiers is also different. Our example would become:\nx = 1/11\nprint(x)\ns = \"One eleventh is approximately {:.2f}\"\nprint(s)\nprint(s.format(x))\nSimilarly,\nphrase = '{} litres of {} at ${:.2f}/L costs a total of ${:.2f}'\nprint(phrase.format(2, 'milk', 1.29, 2*1.29))\nprint(phrase,format(40, 'petrol', 1.53, 40*1.53))\nprint(phrase.format(7.5, 'water', 0.17, 7.5*0.17))\nThe new approach provides a much richer set of formatting options, described in full in the online documentation. One benefit of the new style is that it is no longer necessary to pass information to format in the same order as it is used: we can number the placeholders. For example,\nphrase = '{3} litres of {0} at ${1:.2f}/L costs a total of ${2:.2f}'\nprint(phrase.format('milk', 1.29, 2*1.29, 2))\nprint(phrase,format('petrol', 1.53, 40*1.53, 40))\nprint(phrase.format('water', 0.17, 7.5*0.17, 7.5))\nThis is particularly useful if you need to repeat the same information several times in a string:\nphrase = \"This sentence has the word {0} {0} {0} repeated three times and the word {1} {1} repeated twice.\"\nprint(phrase.format('cat', 'dog'))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCoding scratch space",
    "crumbs": [
      "**Basic Language Skills**",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Strings</span>"
    ]
  },
  {
    "objectID": "Basics/Ex8-ReadWriteFiles.html",
    "href": "Basics/Ex8-ReadWriteFiles.html",
    "title": "Reading and writing files",
    "section": "",
    "text": "Summary\n\n\n\nIn this section we learn about data-file handling (reading / writing information) which is a pre-cursor to doing useful computing at scale. We will use some very low-level tools to read and write to storage. In practice, we would probably use packages that can read common data formats, download data from the web, or work with datasets that are too large to read all at once.\n\n\nUp to this point, we have typed all the data for our programs in ‘by hand’. However, as you have no doubt noticed, this quickly gets tedious. It is useful to be able to read and write data files, allowing information to be stored and shared with other people.\nIn order to read a data file, we need to understand what information it contains, and how this has been encoded. This is generally referred to as the ‘file format’. Different programs produce files in different formats - a photograph in .jpeg format cannot be read by a spreadsheet package, which might expect to receive files in .xlsx format.\nThe simplest file format for storing and transferring scientific data is a plain text file in ‘ascii’ (‘American Standard Code for Information Exchange’) format. This is the sort of file that can be read and produced using a simple text editor such as ‘notepad’ (on Windows) or ‘TextEdit’ (on a Mac). Commonly, such files will have an extension such as .txt or .dat.\nReading ascii files in Python is a four-step process: 1. Open the file; 2. Read each line from the file; 3. Parse each line (i.e., extract the required information from it); 4. Close the file.\n\n\n\n\n\n\nSetup Code (runs first)\n\n\n\n\n\nWe need to make sure the data file we are going to use is saved on your computer so we first have to make a copy into the sandbox file system we are using (this area is deleted whenever we reload this page). The code below should have run as the page loads. Check that the file is in the correct location, and re-run the setup code if it is not there.\n\n\n\n\n\n\nWe can check to see if the file is available\n\n\n\n\n\n\n\n\n\n\nReading data from a file\nTo open a file, we use the open() function, which returns a file object. It is important to assign this to a variable (here, fp) so that we can continue to access the open file.\nfilename = 'sample.dat'\nfp = open(filename, 'r')\nHere, filename is a variable holding the file name (or file path and name, if it is not in our current working directory), and the second argument, 'r', specifies that we want to open the file for reading only.\nOnce the file is open, we can read from it. There are various ways of doing this, but for small files the simplest method is generally to call the readlines() function, which returns the entire file in the form of a list:\nlines = fp.readlines()\nEach element of the list lines is now a string, containing one of the lines from the file sample.dat. Since we have read all the information in the file, we can now close the file:\nfp.close()\n\n\n\n\n\n\nExercise 1 - Read the sample.dat file\n\n\n\n\n\nOpen the file and print out the individual lines to see what it contains.\nHere is a hint that you might see in python code elsewhere. If you precede a structure like a tuple or list with a ’ * ’ then it is unpacked before being used. This might be helpful if you want to make the list of lines look more like the original file when printed. Another way would be to write a loop over all the lines and print them individually.\n\n    t = (1,2,3,4)\n    print(t)\n    print(*t)\n\n    # Output:\n    # (1, 2, 3, 4)\n    # 1 2 3 4\n\n\n    l = ['a', 'b', 'c', '...', 'z']\n    print(l)\n    print(*l)\n\n    # Output:\n    # ['a', 'b', 'c', '...', 'z']\n    # a b c ... z\n\n\n\n\n\n\n\n\n\n\n\n\npython with statement\nOpening and closing files explicitly is useful to illustrate how Python handles reading and writing files. However, doing this in practice can get quite messy because these ‘connections’ to files stay open until you explicitly close them. With single files, this can lead to data corruption and data loss, with more complex scripts you might open 10,000 files and not close any of them - you may then run into some limit on the system that will block your script or may block some other work that you are trying to do.\nPython has a really handy construct for dealing with this issue automatically and you will doubtless see code that uses ‘context managers’ aka with statements.\nThis is not a very intuitive choice of language but, once you recognise what is happening, you will be able to understand python programs more easily. Any time you have an action which needs some clearing-up to be done afterwards, the context manager handles everything behind the scenes.\nIn the case of reading/writing files, you create a ‘context’ that contains a connection to a file, which is automatically closed when the code within the context is finished. This is a bit complicated to follow, but file-management is a very clear example of how it works.\nfilename = 'sample.dat'\nwith open(filename, 'r') as fp:\n    lines = fp.readlines()\n    ...\n    ...\n\n    # fp.close() is handled automatically here\nThe with statement tells python that the file you’re giving it is only used in the following indented code, and can be closed afterwards. This performs exactly the same as manually opening and closing the file, as above, but automatically cleans up after you.\n\n\n\n\n\n\nExercise 2 - context manager\n\n\n\n\n\nCan you test to see if the fp was closed / deleted after the statement completed ? What about the contents of the file, are they available once the with statement is done ?\n\n\n\n\n\n\n\n\n\nOnce you have a list of strings, you can use the list- and string-parsing tools we have already encountered to extract the necessary data and store it in appropriate data structures. The file sample.dat contains records of the mass and volume of twenty samples of a given material.\n\n\n\n\n\n\nExercise 3 - work with the data\n\n\n\n\n\nRead the data from this file, compute the density of each sample and hence the average density of the material.\n\nYou will need to parse the individual strings and store the information for your calculations.\nOutput the information to the screen with print statements so that you can validate your results.\n\n\n\n\n\n\n\n\n\n\n\n\nWriting data to a file\nWe don’t want to have to repeat this work once the processing is done, so we would like to write out the new information to a file.\nTo write data to file, we need to first open the file for writing. This can be done by using ‘w’ instead of ‘r’ when opening the file. Note that if a file already exists with the specified name, it will be immediately overwritten and lost. To avoid this, you can instead use ‘x’ when opening the file. This will throw an error if there is an existing file, rather than overwrite it. Again, when opening the file it is important to assign the result of open() to a variable, so we can write to it.\nOnce the file is open, we can write any text strings to it by calling the write() function. Remember, to insert a new line, you use the symbol '\\n', otherwise everything will be on a single line:\nfp.write(\"Hello!\\n\")\nfp.write(\"This is some text to store in a file... \")\nline = \"The file has only two lines.\"\nfp.write(line)\nOnce everything is written to the file, call close() to close it.\nfp.close()\n\n\n\n\n\n\nExercise 4 - write data to a new file\n\n\n\n\n\nCreate a new file, based on the data you read earlier. It should contain three columns: mass, sample volume and sample density. All quantities should be in SI units.\n*Remember, you can use the string-formatting tools we encountered in the last exercise to control how your numbers are written out. Verify that the file has been correctly written (e.g. Exercise 1)\n\n\n\n\n\n\n\n\n\nFrom the examples above, we just saw how to read and write data using Python built-in methods. These are good for simple files, but not for more complex information such as an Excel spreadsheet. Later in the course, we will encounter a number of more sophisticated tools that can help us with these kinds of files.\n\n\nSandbox\n\n\n\n\n\n\nCoding scratch space",
    "crumbs": [
      "**Basic Language Skills**",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Reading and writing files</span>"
    ]
  },
  {
    "objectID": "Applications/Ex1-IntroductionToMatplotlib.html",
    "href": "Applications/Ex1-IntroductionToMatplotlib.html",
    "title": "Plotting graphs with Matplotlib",
    "section": "",
    "text": "Introduction to matplotlib\nMatplotlib will help you to plot graphs from your data, and is a great starting point when you need to see if something is working or not. It can be used for complicated plots and figures for publication of your results. The default interface makes simple tasks trivial but is hard to extend when you need a more refined graph.\nMatplotlib fully embraces the python object-oriented model, but for some tasks the design of the object hierarchy is a little bit counter-intuitive. It’s best to find a common pattern for building plots and stick to it.\nIn matplotlib, the figure is the top-level container for all the plot elements but it does little more than hold onto sets of axes which are the primary objects you will interact with.\nTo look at the rendered image we can either browse with the jupyterlab file browser or, if we are running in the browser, we can use the display function from the IPython.display module to display the image.",
    "crumbs": [
      "**Applications for Earth Sciences**",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Plotting graphs with Matplotlib</span>"
    ]
  },
  {
    "objectID": "Applications/Ex1-IntroductionToMatplotlib.html#introduction-to-matplotlib",
    "href": "Applications/Ex1-IntroductionToMatplotlib.html#introduction-to-matplotlib",
    "title": "Plotting graphs with Matplotlib",
    "section": "",
    "text": "Online gallery / cookbook\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExamples\nThe figure is just used once in a typical, simple plotting routine. The axis / axes are used as a container for all of an individual graph’s information. The subplot arguments are rather typical of matplotlib - a 1960s, fortran-like parsing of a three digit integer (above) or three separate arguments that imply the same thing (below). Which of these is the better choice to use, and why ?\n\n\n\n\n\n\nIt’s not just plot that can add data to an axis, the style of the plot is largely controlled by the routine that add the data to a given axis. You can add multiple data to an axis and you can do this in multiple formats.\n\n\n\n\n\n\nHere are some more examples that you can explore.\n\n\n\n\n\n\n\n\nMatplotlib Gallery\nThe gallery is a collection of examples that demonstrate the range ofcapabilities of matplotlib. Source code is provided for each example and they should all work here.\nIt is worth using the gallery as a starting point for the plots you want to create. The interface to matplotlib objects is powerful but not designed for everyday use - to do slightly complicated things may require very complicated code. But lots can be done and here are some cool examples.\n\n\n\n\n\n\nGallery 1 - Line plots with Error Bars\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGallery 2 - Triangulation, Contours\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGallery 3 - Hillshading\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGallery 4 - Statistical Plots",
    "crumbs": [
      "**Applications for Earth Sciences**",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Plotting graphs with Matplotlib</span>"
    ]
  },
  {
    "objectID": "Applications/Ex2-IntroductingCartopy.html",
    "href": "Applications/Ex2-IntroductingCartopy.html",
    "title": "Introduction to Cartopy for Map-making",
    "section": "",
    "text": "Let’s get started\nWe are going to work through a number of the examples and try to extend them to do the kinds of things you might find interesting and useful in the future. The examples are in the form of a gallery\nYou might also want to look at the list of map projections from time to time. Not all maps can be plotted in every projection (sometimes because of bugs and sometimes because they are not supposed to work for the data you have) but you can try them and see what happens.\nCartopy is built on top of a lot of the matplotlib graphing tools. It works by introducing a series of projections associated with the axes of a graph. On top of that there is a big toolkit for reading in images, finding data from standard web feeds, and manipulating geographical objects. Many, many libraries are involved and sometimes things break. Luckily the installation that is built for this course is about as reliable as we can ever get. I’m just warning you, though, that it can be quite tough if you want to put this on your laptop from scratch.\nWe have a number of imports that we will need almost every time.\nIf we are going to plot anything then we need to include matplotlib.\nThe simplest plot: global map using the default image built into the package and adding coastlines\nTry changing the projection - look at the list in the link I gave you above to see what ccrs has available. In the notebook, many of the projections will time out because they are so computationally intensive but these work: EckartI, EckartV, Stereographic, Orthographic, LambertConformal, Miller, `Mollweide.\nHere is how you can plot a region instead of the globe:",
    "crumbs": [
      "**Applications for Earth Sciences**",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Introduction to Cartopy for Map-making</span>"
    ]
  }
]